<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Meeting Recorder - Media Handler</title>
  </head>
  <body>
    <script>
      console.log("Offscreen document loaded");

      class OffscreenMediaHandler {
        constructor() {
          this.mediaRecorder = null;
          this.recordingData = [];
          this.stream = null;

          // Listen for messages from background script
          chrome.runtime.onMessage.addListener(
            (request, sender, sendResponse) => {
              console.log("Offscreen received message:", request.action);
              this.handleMessage(request, sender, sendResponse);
              return true; // Keep message channel open for async response
            }
          );

          console.log("OffscreenMediaHandler initialized");
        }

        async handleMessage(request, sender, sendResponse) {
          try {
            switch (request.action) {
              case "startCapture":
                console.log("Starting capture with options:", request.options);
                const result = await this.startCapture(request.options);
                console.log("Capture start result:", result);
                sendResponse(result);
                break;

              case "stopCapture":
                console.log("Stopping capture");
                const stopResult = await this.stopCapture();
                console.log("Capture stop result:", stopResult);
                sendResponse(stopResult);
                break;

              default:
                console.log("Unknown action:", request.action);
                sendResponse({ success: false, error: "Unknown action" });
            }
          } catch (error) {
            console.error("Error handling message:", error);
            sendResponse({ success: false, error: error.message });
          }
        }

        async startCapture(options) {
          try {
            console.log("Checking media devices availability...");

            // Check if navigator.mediaDevices is available
            if (
              !navigator.mediaDevices ||
              typeof navigator.mediaDevices.getUserMedia !== "function"
            ) {
              throw new Error("Media APIs not available in this context");
            }

            let finalStream = null;

            if (options.includeScreen) {
              console.log("Requesting screen capture...");

              // Check for getDisplayMedia support
              if (
                typeof navigator.mediaDevices.getDisplayMedia !== "function"
              ) {
                throw new Error("Screen capture not supported");
              }

              const screenStream = await navigator.mediaDevices.getDisplayMedia(
                {
                  video: {
                    mediaSource: "screen",
                    width: { ideal: 1920, max: 1920 },
                    height: { ideal: 1080, max: 1080 },
                    frameRate: { ideal: 30, max: 30 },
                  },
                  audio: options.includeSystemAudio || false,
                }
              );

              console.log("Screen capture obtained");

              if (options.includeAudio) {
                try {
                  console.log("Requesting microphone access...");
                  const micStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                      echoCancellation: true,
                      noiseSuppression: true,
                      autoGainControl: true,
                      sampleRate: { ideal: 48000 },
                      channelCount: { ideal: 2 },
                    },
                  });

                  console.log("Microphone access obtained");
                  // Combine streams
                  finalStream = this.combineStreams(screenStream, micStream);
                } catch (micError) {
                  console.warn("Could not access microphone:", micError);
                  finalStream = screenStream;
                }
              } else {
                finalStream = screenStream;
              }
            } else if (options.includeAudio) {
              console.log("Requesting audio-only recording...");
              // Audio-only recording
              finalStream = await navigator.mediaDevices.getUserMedia({
                audio: {
                  echoCancellation: true,
                  noiseSuppression: true,
                  autoGainControl: true,
                  sampleRate: { ideal: 48000 },
                  channelCount: { ideal: 2 },
                },
              });
            } else {
              throw new Error("No recording source specified");
            }

            this.stream = finalStream;
            console.log("Final stream obtained:", finalStream);

            // Create MediaRecorder
            const mimeType = this.getBestMimeType();
            console.log("Using MIME type:", mimeType);

            this.mediaRecorder = new MediaRecorder(this.stream, {
              mimeType: mimeType,
              videoBitsPerSecond: this.getVideoBitrate(options.videoQuality),
              audioBitsPerSecond: this.getAudioBitrate(options.audioQuality),
            });

            this.recordingData = [];

            // Handle data availability
            this.mediaRecorder.ondataavailable = (event) => {
              if (event.data.size > 0) {
                console.log(
                  "Recording data chunk received:",
                  event.data.size,
                  "bytes"
                );
                this.recordingData.push(event.data);
              }
            };

            // Handle recording stop
            this.mediaRecorder.onstop = () => {
              console.log("MediaRecorder stopped");
              this.handleRecordingComplete();
            };

            // Handle errors
            this.mediaRecorder.onerror = (event) => {
              console.error("MediaRecorder error:", event.error);
              chrome.runtime.sendMessage({
                action: "recordingError",
                error: event.error.message,
              });
            };

            // Start recording
            this.mediaRecorder.start(1000); // Collect data every second
            console.log("MediaRecorder started");

            return { success: true, mimeType: mimeType };
          } catch (error) {
            console.error("Failed to start capture:", error);
            return { success: false, error: error.message };
          }
        }

        async stopCapture() {
          try {
            console.log("Stopping capture...");

            if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
              this.mediaRecorder.stop();
              console.log("MediaRecorder stopped");
            }

            if (this.stream) {
              this.stream.getTracks().forEach((track) => {
                track.stop();
                console.log("Track stopped:", track.kind);
              });
              this.stream = null;
            }

            return { success: true };
          } catch (error) {
            console.error("Failed to stop capture:", error);
            return { success: false, error: error.message };
          }
        }

        combineStreams(videoStream, audioStream) {
          const videoTracks = videoStream.getVideoTracks();
          const screenAudioTracks = videoStream.getAudioTracks();
          const micAudioTracks = audioStream.getAudioTracks();

          console.log("Combining streams:", {
            videoTracks: videoTracks.length,
            screenAudioTracks: screenAudioTracks.length,
            micAudioTracks: micAudioTracks.length,
          });

          // Create new stream with video and both audio sources
          const combinedStream = new MediaStream([
            ...videoTracks,
            ...screenAudioTracks,
            ...micAudioTracks,
          ]);

          return combinedStream;
        }

        getBestMimeType() {
          const types = [
            "video/webm;codecs=vp9,opus",
            "video/webm;codecs=vp8,opus",
            "video/webm;codecs=h264,opus",
            "video/webm",
            "video/mp4",
          ];

          const supportedType = types.find((type) =>
            MediaRecorder.isTypeSupported(type)
          );
          console.log("Best MIME type found:", supportedType);
          return supportedType || "video/webm";
        }

        getVideoBitrate(quality) {
          const bitrates = {
            low: 500000, // 500kbps
            medium: 1000000, // 1Mbps
            high: 2500000, // 2.5Mbps
          };
          return bitrates[quality] || bitrates.medium;
        }

        getAudioBitrate(quality) {
          const bitrates = {
            low: 64000, // 64kbps
            medium: 128000, // 128kbps
            high: 192000, // 192kbps
          };
          return bitrates[quality] || bitrates.medium;
        }

        async handleRecordingComplete() {
          try {
            console.log("Handling recording completion...");
            console.log("Recording data chunks:", this.recordingData.length);

            if (this.recordingData.length === 0) {
              throw new Error("No recording data available");
            }

            // Create blob from recorded data
            const recordingBlob = new Blob(this.recordingData, {
              type: this.mediaRecorder.mimeType,
            });

            console.log("Recording blob created:", recordingBlob.size, "bytes");

            // Convert to base64 for transfer
            const base64Data = await this.blobToBase64(recordingBlob);
            console.log("Base64 conversion complete");

            // Send to background script
            chrome.runtime.sendMessage({
              action: "recordingComplete",
              data: {
                blob: base64Data,
                mimeType: this.mediaRecorder.mimeType,
                size: recordingBlob.size,
              },
            });

            console.log("Recording completion message sent to background");
          } catch (error) {
            console.error("Error handling recording completion:", error);
            chrome.runtime.sendMessage({
              action: "recordingError",
              error: error.message,
            });
          }
        }

        blobToBase64(blob) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        }
      }

      // Initialize media handler
      new OffscreenMediaHandler();
    </script>
  </body>
</html>
